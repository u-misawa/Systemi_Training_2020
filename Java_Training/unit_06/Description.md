### 第6章　コレクションフレームワーク
1. コレクションフレームワークの基本
* コレクションフレームワークの中でも、最も基本となるのはCollectionインターフェイス。Collectionのサブインターフェイスとして、さらに、List、Set、Queue(Deque)があり、Collectionとは継承関係にないもののMapが加わっコレクションフレームワークの基本的な構成としている。  
* コレクションの基本構文  
  * インターフェイス型  
  * ジェネリクス構文  
* コーディング上のイディオム  
  * コレクション初期化  
  * コレクションを順に処理する 拡張for命令を使用  
* 配列⇔コレクションの変換  
  * 配列→リスト Arrays.asListメソッドを使用  
  * 配列→リスト(コピー) Collections.addAll静的メソッドを使用  
  * コレクション→配列 toArrayメソッドを使用  
* 特殊なコレクションの作成  
  *変更不能コレクションへの変換 unmodifiableXxxxxメソッドを使用  
  * 変更不能コレクションの生成 ofメソッドを使用  
  * 空コレクションの生成  emptyXxxxxメソッドを使用  
2. リスト  
* ArrayList(サイズ可変の配列)  
  * 内部的には配列を利用したデータ構造です。ただし、配列とは異なり、あとからでもサイズを変更できる。  
* LinkedList(二重リンクリスト)  
  * ArrayListで利用できるメンバーに加えP243 表6.6のメンバーが用意されている。  
3. セット  
リストと違いセットは要素の重複を許さない。数学における集合の概念に似ており、ある要素(群)がセットに含まれているか、他のセットとも包含関係に関心があるような状況で使用する。  
* セットの基本操作(HashSet)  
  * P251 表6.7参照  
* TreeSet(ソート済セット)  
  * 並び順を管理する。追加された要素が自動的にソートされる点を除けば、HashSetと同じ挙動となる。P253 表6.8参照  
4. マップ  
一意のキーと値のペアで管理されているデータ構造。言語によってはディクショナリ(辞書)、ハッシュ、連想配列と呼ぶ場合もある。個々の要素に対して(インデックスではなく)キーと言う意味ある情報でアルセスができる。  
* HashMap(ハッシュ表)  
最も基本的なマップの実装。キーの順序は保証されない。  
内部的にはハッシュ表(ハッシュテーブル)と呼ばれる配列を持つ。要素を保存する際に、キーからハッシュ値を求めることで、ハッシュ表のどこに値(オブジェクト)を保存するのに決定する。 
  * hashCodeメソッドは適切に実装する。  
  * ハッシュ表のサイズを適切に設定する。  
  * HashMapで用意されているメンバー P257 表6.9参照  
* TreeMap(ソート済マップ)  
キーの順序を管理できるマップです。キーをRed-Blackツリーで管理し、キーの大小で並びを管理できるのが特徴。  
  * キーの順序をカスタマイズ 既定でキーとなる型の自然順序(文字列ならば辞書順、数値ならば大小順)に従って、要素の並びを決定する。標準の並びを順を変更したい場合は、インスタンス化するときにラムダ式を渡すようにする。  
  * NavigableMapによるあいまい検索  指定されたキーそのものではなく、そのキーに最も近いキーを取得するためのメソッドを提供する。  
5. スタック/キュー  
リストの両端からの値の出し入れに特化したデータ構造のこと。  
スタック(stack)とは後入れ先出し(LIFO:Last In First Out)、または先入れ後出し(FILO:First In Last Out)とも呼ばれる構造。  
キュー(Queue)は先入れ先出し(FIFO:First In First Out)と呼ばれるデータ構造。  
* ArrayDeque(両端キュー)  
  * 循環配列のこと。循環配列とは、基本的には配列だが、先頭から順に要素を格納するのではなく、配列内の任意の範囲に要素を格納しているのが特徴。P268 表6.11参照  
